/**
 * Nodemailer email service configuration and helper functions
 * This module provides type-safe helpers for sending emails using Nodemailer SMTP
 * Enhanced to support the notification system requirements
 *
 * Generated by Copilot
 */

import nodemailer from 'nodemailer';
import type { Transporter } from 'nodemailer';
import SMTPTransport from 'nodemailer/lib/smtp-transport';

/**
 * Email recipient type definition
 */
export interface EmailRecipient {
  email: string;
  name?: string;
}

/**
 * Base email configuration interface
 */
export interface EmailConfig {
  from: EmailRecipient;
  to: EmailRecipient | EmailRecipient[];
  subject: string;
  cc?: EmailRecipient | EmailRecipient[];
  bcc?: EmailRecipient | EmailRecipient[];
  replyTo?: string;
}

/**
 * Text-based email configuration
 */
export interface TextEmailConfig extends EmailConfig {
  text: string;
}

/**
 * HTML-based email configuration
 */
export interface HtmlEmailConfig extends EmailConfig {
  html: string;
}

/**
 * Combined email configuration type
 */
export type SendEmailConfig = TextEmailConfig | HtmlEmailConfig;

/**
 * Legacy email sending options interface (maintained for compatibility)
 */
export interface EmailOptions {
  to: string;
  subject: string;
  html: string;
  text?: string;
  from?: string;
}

/**
 * SMTP service configuration interface
 */
interface SMTPServiceConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
}

/**
 * Email service result interface
 */
export interface EmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

/**
 * Legacy email service functions for backward compatibility
 * These functions provide a simpler interface for basic email sending
 */

/**
 * Get the default from email address
 */
export const getDefaultFromEmail = (): string => {
  return process.env.EMAIL_FROM || 'noreply@dashi.app';
};

/**
 * Send an email using legacy EmailOptions interface
 * @param options Email sending options
 * @returns Promise with email result
 */
export const sendLegacyEmail = async (options: EmailOptions): Promise<EmailResult> => {
  try {
    const transporter = createEmailTransporter();

    const mailOptions = {
      from: options.from || getDefaultFromEmail(),
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text,
    };

    const info = await transporter.sendMail(mailOptions);

    return {
      success: true,
      messageId: info.messageId,
    };
  } catch (error) {
    console.error('Failed to send email:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
};

/**
 * Send a test email to verify configuration
 * @param to Recipient email address
 * @returns Promise with email result
 */
export const sendTestEmail = async (to: string): Promise<EmailResult> => {
  const testOptions: EmailOptions = {
    to,
    subject: 'Dashi Email Service Test',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #f97316;">Dashi Email Service</h1>
        <p>This is a test email to verify that the Nodemailer configuration is working correctly.</p>
        <p>If you received this email, the email service is configured properly.</p>
        <hr style="border: 1px solid #e5e7eb; margin: 20px 0;">
        <p style="color: #6b7280; font-size: 14px;">
          This email was sent from the Dashi platform email service.
        </p>
      </div>
    `,
    text: 'This is a test email from Dashi. If you received this, the email service is working correctly.',
  };

  return sendLegacyEmail(testOptions);
};

/**
 * Check if the email service is properly configured
 * @returns boolean indicating if service is ready
 */
export const isEmailServiceConfigured = (): boolean => {
  try {
    createSMTPConfig();
    return true;
  } catch {
    return false;
  }
};

/**
 * SMTP configuration creation utilities
 */

/**
 * Creates SMTP configuration from environment variables
 */
export const createSMTPConfig = (): SMTPServiceConfig => {
  const host = process.env.SMTP_HOST;
  const port = process.env.SMTP_PORT;
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;

  if (!host || !port || !user || !pass) {
    throw new Error(
      'Missing required SMTP environment variables: SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS'
    );
  }

  const portNumber = parseInt(port, 10);
  if (isNaN(portNumber)) {
    throw new Error('SMTP_PORT must be a valid number');
  }

  return {
    host,
    port: portNumber,
    secure: portNumber === 465, // true for 465, false for other ports
    auth: {
      user,
      pass,
    },
  };
};

/**
 * Creates a Nodemailer transporter instance using SMTP configuration
 */
export const createEmailTransporter = (): Transporter<SMTPTransport.SentMessageInfo> => {
  const config = createSMTPConfig();
  return nodemailer.createTransport(config);
};

/**
 * Enhanced Email Service Functions
 */

/**
 * Formats email recipient for nodemailer
 */
const formatRecipient = (recipient: EmailRecipient): string => {
  return recipient.name ? `${recipient.name} <${recipient.email}>` : recipient.email;
};

/**
 * Formats multiple recipients for nodemailer
 */
const formatRecipients = (recipients: EmailRecipient | EmailRecipient[]): string | string[] => {
  if (Array.isArray(recipients)) {
    return recipients.map(formatRecipient);
  }
  return formatRecipient(recipients);
};

/**
 * Main helper function to send an email using Nodemailer
 *
 * @param config - Email configuration including recipients, subject, and content
 * @returns EmailResult with success status and either messageId or error
 */
export const sendEmail = async (config: SendEmailConfig): Promise<EmailResult> => {
  try {
    // Validate configuration first
    validateEmailConfig(config);

    const transporter = createEmailTransporter();

    // Format recipients
    const to = formatRecipients(config.to);
    const cc = config.cc ? formatRecipients(config.cc) : undefined;
    const bcc = config.bcc ? formatRecipients(config.bcc) : undefined;
    const from = formatRecipient(config.from);

    // Prepare email data
    const mailOptions = {
      from,
      to,
      subject: config.subject,
      cc,
      bcc,
      replyTo: config.replyTo,
      ...('html' in config ? { html: config.html } : { text: config.text }),
    };

    // Send email
    const info = await transporter.sendMail(mailOptions);

    return {
      success: true,
      messageId: info.messageId,
    };
  } catch (error) {
    console.error('Email sending failed with exception:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
};

/**
 * Simplified helper for sending plain text emails
 *
 * @param to - Recipient email address or object with name and email
 * @param subject - Email subject line
 * @param text - Plain text email content
 * @param from - Optional sender (defaults to configured default sender)
 * @returns Email sending result
 */
export const sendTextEmail = async (
  to: EmailRecipient | EmailRecipient[],
  subject: string,
  text: string,
  from?: EmailRecipient
): Promise<EmailResult> => {
  const defaultFrom: EmailRecipient = {
    email: process.env.EMAIL_FROM || 'noreply@dashi.app',
    name: 'Dashi',
  };

  return sendEmail({
    from: from || defaultFrom,
    to,
    subject,
    text,
  });
};

/**
 * Simplified helper for sending HTML emails
 *
 * @param to - Recipient email address or object with name and email
 * @param subject - Email subject line
 * @param html - HTML email content
 * @param from - Optional sender (defaults to configured default sender)
 * @returns Email sending result
 */
export const sendHtmlEmail = async (
  to: EmailRecipient | EmailRecipient[],
  subject: string,
  html: string,
  from?: EmailRecipient
): Promise<EmailResult> => {
  const defaultFrom: EmailRecipient = {
    email: process.env.EMAIL_FROM || 'noreply@dashi.app',
    name: 'Dashi',
  };

  return sendEmail({
    from: from || defaultFrom,
    to,
    subject,
    html,
  });
};

/**
 * Validates email configuration
 *
 * @param config - Email configuration to validate
 * @returns true if valid, throws error if invalid
 */
export const validateEmailConfig = (config: SendEmailConfig): boolean => {
  if (!config.from?.email) {
    throw new Error('From email address is required');
  }

  if (!config.to) {
    throw new Error('To email address is required');
  }

  if (!config.subject?.trim()) {
    throw new Error('Email subject is required');
  }

  if (!('text' in config) && !('html' in config)) {
    throw new Error('Email must have either text or html content');
  }

  if ('text' in config && !config.text?.trim()) {
    throw new Error('Email text content cannot be empty');
  }

  if ('html' in config && !config.html?.trim()) {
    throw new Error('Email HTML content cannot be empty');
  }

  // Validate email addresses
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  if (!emailRegex.test(config.from.email)) {
    throw new Error('Invalid from email address');
  }

  const validateRecipients = (recipients: EmailRecipient | EmailRecipient[]) => {
    const recipientArray = Array.isArray(recipients) ? recipients : [recipients];
    for (const recipient of recipientArray) {
      if (!emailRegex.test(recipient.email)) {
        throw new Error(`Invalid email address: ${recipient.email}`);
      }
    }
  };

  validateRecipients(config.to);
  if (config.cc) validateRecipients(config.cc);
  if (config.bcc) validateRecipients(config.bcc);

  return true;
};

/**
 * Test SMTP connection
 *
 * @returns Promise<boolean> - true if connection successful
 */
export const testSMTPConnection = async (): Promise<boolean> => {
  try {
    const transporter = createEmailTransporter();
    await transporter.verify();
    return true;
  } catch (error) {
    console.error('SMTP connection test failed:', error);
    return false;
  }
};
